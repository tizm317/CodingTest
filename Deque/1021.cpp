//#include <iostream>
//#include <deque>
//#include <iterator>
//using namespace std;
//
//// 백준 문제 풀이
//// 날짜		: 2023. 05. 20. 토
//// 문제 번호	: #1021
//// 문제 이름	: 회전하는 큐
//// 알고리즘	: 
//// 시간복잡도: O()
//
//int N, M, moveCnt;
//deque<int> intDeque;
//int idx[50];
//
//// 1. 첫번째 원소 뽑아낸다 => front / pop_front
//// 1 2 3 4 5 -> 2 3 4 5
//// 2. 왼쪽 한칸 이동 
//// 1 2 3 4 5 -> 2 3 4 5 1
//// 3. 오른쪽 한칸 이동
//// 1 2 3 4 5 -> 5 1 2 3 4
//
//int main()
//{
//	ios_base::sync_with_stdio(false);
//	cin.tie(NULL);
//
//	cin >> N >> M;
//	for (int i = 1; i <= N; i++)
//	{
//		intDeque.push_back(i);
//	}
//
//	for (int i = 0; i < M; i++)
//	{
//		int x;
//		cin >> x;
//		idx[i] = x - 1; // 몇번째 -> idx로 변환 저장
//	}
//
//	// 1 8 4 -> 0 7 3
//	for (int target = 0; target < M; target++)
//	{
//		while (idx[target] != 0)
//		{
//			// 0번째로 오기까지 차이
//			int left = idx[target];
//			int right = N - idx[target];
//			
//			// 정방향(왼쪽으로 이동)
//			if (left < right)
//			{
//				for (int i = 0; i < M; i++)
//				{
//					if (idx[i] == -1)
//						continue;
//
//					idx[i]--;
//
//					if (idx[i] == -1)
//						idx[i] = N - 1; // 0 -> -1(=N-1번째)
//				}
//			}
//			// 역방향(오른쪽으로 이동)
//			else
//			{
//				for (int i = 0; i < M; i++)
//				{
//					if (idx[i] == -1)
//						continue;
//
//					idx[i]++;
//					idx[i] %= N; // N-1 -> N(=0번째)
//				}
//			}
//
//			moveCnt++;
//		}
//
//
//		//idx[target] = -1;
//		for (int i = 0; i < M; i++)
//		{
//			if (idx[i] == -1)
//				continue;
//
//			idx[i]--;
//		}
//
//		// 0번째 도달 -> pop : 전체 갯수 감소
//		N--;
//	}
//
//	cout << moveCnt;
//
//	// 10 3
//	// 뽑아내려고 하는 위치 : 1 2 3
//	// 1 2 3 4 5 6 7 8 9 10
//	// 1번 행동 * 3번 -> 4 5 6 7 8 9 10
//	// 0 출력
//
//	// 10 3
//	// 2 9 5
//	// 1 2 3 4 5 6 7 8 9 10
//	// 2 -> 2 3 4 5 6 7 8 9 10 1	// 1
//	// 1 -> 3 4 5 6 7 8 9 10 1 (2)
//	// 3 -> 1 3 4 5 6 7 8 9 10		// 2
//	// 3 -> 10 1 3 4 5 6 7 8 9		// 3
//	// 3 -> 9 10 1 3 4 5 6 7 8		// 4
//	// 1 -> 10 1 3 4 5 6 7 8 (9)
//	// 2 -> 1 3 4 5 6 7 8 10		// 5
//	// 2 -> 3 4 5 6 7 8 10 1		// 6
//	// 2 -> 4 5 6 7 8 10 1 3		// 7
//	// 2 -> 5 6 7 8 10 1 3 4		// 8
//	// 1 -> 6 7 8 10 1 3 4 (5)
//
//	// 정방향(왼쪽으로)
//	// 0 1 2 3 4 5 6 7 8 9
//	// 역방향(오른쪽으로)
//	// 0 9 8 7 6 5 4 3 2 1
//
//	return 0;
//}